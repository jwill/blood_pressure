// AUTO GENERATED BY JNIGEN 0.14.2. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'Instant.dart' as instant$_;

import 'ZoneOffset.dart' as zoneoffset$_;

/// from: `java.time.ZonedDateTime`
class ZonedDateTime extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ZonedDateTime> $type;

  @jni$_.internal
  ZonedDateTime.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/ZonedDateTime');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ZonedDateTime$NullableType();
  static const type = $ZonedDateTime$Type();
  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? format(
    jni$_.JObject? dateTimeFormatter,
  ) {
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _format(reference.pointer, _id_format as jni$_.JMethodIDPtr,
            _$dateTimeFormatter.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/ZonedDateTime;',
  );

  static final _from = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? from(
    jni$_.JObject? temporalAccessor,
  ) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(_class.reference.pointer, _id_from as jni$_.JMethodIDPtr,
            _$temporalAccessor.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(
    jni$_.JObject? temporalField,
  ) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(reference.pointer, _id_get as jni$_.JMethodIDPtr,
            _$temporalField.pointer)
        .integer;
  }

  static final _id_getDayOfMonth = _class.instanceMethodId(
    r'getDayOfMonth',
    r'()I',
  );

  static final _getDayOfMonth = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getDayOfMonth()`
  int getDayOfMonth() {
    return _getDayOfMonth(
            reference.pointer, _id_getDayOfMonth as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getDayOfWeek = _class.instanceMethodId(
    r'getDayOfWeek',
    r'()Ljava/time/DayOfWeek;',
  );

  static final _getDayOfWeek = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.DayOfWeek getDayOfWeek()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getDayOfWeek() {
    return _getDayOfWeek(
            reference.pointer, _id_getDayOfWeek as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getDayOfYear = _class.instanceMethodId(
    r'getDayOfYear',
    r'()I',
  );

  static final _getDayOfYear = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getDayOfYear()`
  int getDayOfYear() {
    return _getDayOfYear(
            reference.pointer, _id_getDayOfYear as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getHour = _class.instanceMethodId(
    r'getHour',
    r'()I',
  );

  static final _getHour = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getHour()`
  int getHour() {
    return _getHour(reference.pointer, _id_getHour as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(
    jni$_.JObject? temporalField,
  ) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(reference.pointer, _id_getLong as jni$_.JMethodIDPtr,
            _$temporalField.pointer)
        .long;
  }

  static final _id_getMinute = _class.instanceMethodId(
    r'getMinute',
    r'()I',
  );

  static final _getMinute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getMinute()`
  int getMinute() {
    return _getMinute(reference.pointer, _id_getMinute as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getMonth = _class.instanceMethodId(
    r'getMonth',
    r'()Ljava/time/Month;',
  );

  static final _getMonth = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.Month getMonth()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getMonth() {
    return _getMonth(reference.pointer, _id_getMonth as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getMonthValue = _class.instanceMethodId(
    r'getMonthValue',
    r'()I',
  );

  static final _getMonthValue = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getMonthValue()`
  int getMonthValue() {
    return _getMonthValue(
            reference.pointer, _id_getMonthValue as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getNano = _class.instanceMethodId(
    r'getNano',
    r'()I',
  );

  static final _getNano = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getNano()`
  int getNano() {
    return _getNano(reference.pointer, _id_getNano as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getOffset = _class.instanceMethodId(
    r'getOffset',
    r'()Ljava/time/ZoneOffset;',
  );

  static final _getOffset = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.ZoneOffset getOffset()`
  /// The returned object must be released after use, by calling the [release] method.
  zoneoffset$_.ZoneOffset? getOffset() {
    return _getOffset(reference.pointer, _id_getOffset as jni$_.JMethodIDPtr)
        .object<zoneoffset$_.ZoneOffset?>(
            const zoneoffset$_.$ZoneOffset$NullableType());
  }

  static final _id_getSecond = _class.instanceMethodId(
    r'getSecond',
    r'()I',
  );

  static final _getSecond = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getSecond()`
  int getSecond() {
    return _getSecond(reference.pointer, _id_getSecond as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getYear = _class.instanceMethodId(
    r'getYear',
    r'()I',
  );

  static final _getYear = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getYear()`
  int getYear() {
    return _getYear(reference.pointer, _id_getYear as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getZone = _class.instanceMethodId(
    r'getZone',
    r'()Ljava/time/ZoneId;',
  );

  static final _getZone = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.ZoneId getZone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getZone() {
    return _getZone(reference.pointer, _id_getZone as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(
    jni$_.JObject? temporalField,
  ) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(reference.pointer,
            _id_isSupported as jni$_.JMethodIDPtr, _$temporalField.pointer)
        .boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(
    jni$_.JObject? temporalUnit,
  ) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(reference.pointer,
            _id_isSupported$1 as jni$_.JMethodIDPtr, _$temporalUnit.pointer)
        .boolean;
  }

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/ZonedDateTime;',
  );

  static final _minus = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.ZonedDateTime minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minus(
    jni$_.JObject? temporalAmount,
  ) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(reference.pointer, _id_minus as jni$_.JMethodIDPtr,
            _$temporalAmount.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/ZonedDateTime;',
  );

  static final _minus$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.ZonedDateTime minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minus$1(
    int j,
    jni$_.JObject? temporalUnit,
  ) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(reference.pointer, _id_minus$1 as jni$_.JMethodIDPtr, j,
            _$temporalUnit.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusDays = _class.instanceMethodId(
    r'minusDays',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusDays = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusDays(
    int j,
  ) {
    return _minusDays(reference.pointer, _id_minusDays as jni$_.JMethodIDPtr, j)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusHours = _class.instanceMethodId(
    r'minusHours',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusHours = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusHours(
    int j,
  ) {
    return _minusHours(
            reference.pointer, _id_minusHours as jni$_.JMethodIDPtr, j)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusMinutes = _class.instanceMethodId(
    r'minusMinutes',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusMinutes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusMinutes(
    int j,
  ) {
    return _minusMinutes(
            reference.pointer, _id_minusMinutes as jni$_.JMethodIDPtr, j)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusMonths = _class.instanceMethodId(
    r'minusMonths',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusMonths = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusMonths(
    int j,
  ) {
    return _minusMonths(
            reference.pointer, _id_minusMonths as jni$_.JMethodIDPtr, j)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusNanos = _class.instanceMethodId(
    r'minusNanos',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusNanos = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusNanos(
    int j,
  ) {
    return _minusNanos(
            reference.pointer, _id_minusNanos as jni$_.JMethodIDPtr, j)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusSeconds = _class.instanceMethodId(
    r'minusSeconds',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusSeconds = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusSeconds(
    int j,
  ) {
    return _minusSeconds(
            reference.pointer, _id_minusSeconds as jni$_.JMethodIDPtr, j)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusWeeks = _class.instanceMethodId(
    r'minusWeeks',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusWeeks = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusWeeks(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusWeeks(
    int j,
  ) {
    return _minusWeeks(
            reference.pointer, _id_minusWeeks as jni$_.JMethodIDPtr, j)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusYears = _class.instanceMethodId(
    r'minusYears',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusYears = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? minusYears(
    int j,
  ) {
    return _minusYears(
            reference.pointer, _id_minusYears as jni$_.JMethodIDPtr, j)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _now = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.time.ZonedDateTime now()`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? now() {
    return _now(_class.reference.pointer, _id_now as jni$_.JMethodIDPtr)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/ZonedDateTime;',
  );

  static final _now$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? now$1(
    jni$_.JObject? clock,
  ) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$1(_class.reference.pointer, _id_now$1 as jni$_.JMethodIDPtr,
            _$clock.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _now$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime now(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? now$2(
    jni$_.JObject? zoneId,
  ) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _now$2(_class.reference.pointer, _id_now$2 as jni$_.JMethodIDPtr,
            _$zoneId.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(IIIIIIILjava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _of = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime of(int i, int i1, int i2, int i3, int i4, int i5, int i6, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? of(
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
    int i6,
    jni$_.JObject? zoneId,
  ) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _of(_class.reference.pointer, _id_of as jni$_.JMethodIDPtr, i, i1,
            i2, i3, i4, i5, i6, _$zoneId.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(Ljava/time/LocalDate;Ljava/time/LocalTime;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _of$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime of(java.time.LocalDate localDate, java.time.LocalTime localTime, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? of$1(
    jni$_.JObject? localDate,
    jni$_.JObject? localTime,
    jni$_.JObject? zoneId,
  ) {
    final _$localDate = localDate?.reference ?? jni$_.jNullReference;
    final _$localTime = localTime?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _of$1(_class.reference.pointer, _id_of$1 as jni$_.JMethodIDPtr,
            _$localDate.pointer, _$localTime.pointer, _$zoneId.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_of$2 = _class.staticMethodId(
    r'of',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _of$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime of(java.time.LocalDateTime localDateTime, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? of$2(
    jni$_.JObject? localDateTime,
    jni$_.JObject? zoneId,
  ) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _of$2(_class.reference.pointer, _id_of$2 as jni$_.JMethodIDPtr,
            _$localDateTime.pointer, _$zoneId.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_ofInstant = _class.staticMethodId(
    r'ofInstant',
    r'(Ljava/time/Instant;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _ofInstant = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime ofInstant(java.time.Instant instant, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? ofInstant(
    instant$_.Instant? instant,
    jni$_.JObject? zoneId,
  ) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _ofInstant(
            _class.reference.pointer,
            _id_ofInstant as jni$_.JMethodIDPtr,
            _$instant.pointer,
            _$zoneId.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_ofInstant$1 = _class.staticMethodId(
    r'ofInstant',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneOffset;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _ofInstant$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime ofInstant(java.time.LocalDateTime localDateTime, java.time.ZoneOffset zoneOffset, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? ofInstant$1(
    jni$_.JObject? localDateTime,
    zoneoffset$_.ZoneOffset? zoneOffset,
    jni$_.JObject? zoneId,
  ) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _ofInstant$1(
            _class.reference.pointer,
            _id_ofInstant$1 as jni$_.JMethodIDPtr,
            _$localDateTime.pointer,
            _$zoneOffset.pointer,
            _$zoneId.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_ofLocal = _class.staticMethodId(
    r'ofLocal',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneId;Ljava/time/ZoneOffset;)Ljava/time/ZonedDateTime;',
  );

  static final _ofLocal = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime ofLocal(java.time.LocalDateTime localDateTime, java.time.ZoneId zoneId, java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? ofLocal(
    jni$_.JObject? localDateTime,
    jni$_.JObject? zoneId,
    zoneoffset$_.ZoneOffset? zoneOffset,
  ) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _ofLocal(_class.reference.pointer, _id_ofLocal as jni$_.JMethodIDPtr,
            _$localDateTime.pointer, _$zoneId.pointer, _$zoneOffset.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_ofStrict = _class.staticMethodId(
    r'ofStrict',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneOffset;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _ofStrict = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime ofStrict(java.time.LocalDateTime localDateTime, java.time.ZoneOffset zoneOffset, java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? ofStrict(
    jni$_.JObject? localDateTime,
    zoneoffset$_.ZoneOffset? zoneOffset,
    jni$_.JObject? zoneId,
  ) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _ofStrict(
            _class.reference.pointer,
            _id_ofStrict as jni$_.JMethodIDPtr,
            _$localDateTime.pointer,
            _$zoneOffset.pointer,
            _$zoneId.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/ZonedDateTime;',
  );

  static final _parse = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? parse(
    jni$_.JObject? charSequence,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(_class.reference.pointer, _id_parse as jni$_.JMethodIDPtr,
            _$charSequence.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/ZonedDateTime;',
  );

  static final _parse$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime parse(java.lang.CharSequence charSequence, java.time.format.DateTimeFormatter dateTimeFormatter)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZonedDateTime? parse$1(
    jni$_.JObject? charSequence,
    jni$_.JObject? dateTimeFormatter,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$dateTimeFormatter =
        dateTimeFormatter?.reference ?? jni$_.jNullReference;
    return _parse$1(_class.reference.pointer, _id_parse$1 as jni$_.JMethodIDPtr,
            _$charSequence.pointer, _$dateTimeFormatter.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/ZonedDateTime;',
  );

  static final _plus = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.ZonedDateTime plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plus(
    jni$_.JObject? temporalAmount,
  ) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(reference.pointer, _id_plus as jni$_.JMethodIDPtr,
            _$temporalAmount.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/ZonedDateTime;',
  );

  static final _plus$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.ZonedDateTime plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plus$1(
    int j,
    jni$_.JObject? temporalUnit,
  ) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(reference.pointer, _id_plus$1 as jni$_.JMethodIDPtr, j,
            _$temporalUnit.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusDays = _class.instanceMethodId(
    r'plusDays',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusDays = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusDays(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusDays(
    int j,
  ) {
    return _plusDays(reference.pointer, _id_plusDays as jni$_.JMethodIDPtr, j)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusHours = _class.instanceMethodId(
    r'plusHours',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusHours = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusHours(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusHours(
    int j,
  ) {
    return _plusHours(reference.pointer, _id_plusHours as jni$_.JMethodIDPtr, j)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusMinutes = _class.instanceMethodId(
    r'plusMinutes',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusMinutes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusMinutes(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusMinutes(
    int j,
  ) {
    return _plusMinutes(
            reference.pointer, _id_plusMinutes as jni$_.JMethodIDPtr, j)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusMonths = _class.instanceMethodId(
    r'plusMonths',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusMonths = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusMonths(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusMonths(
    int j,
  ) {
    return _plusMonths(
            reference.pointer, _id_plusMonths as jni$_.JMethodIDPtr, j)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusNanos = _class.instanceMethodId(
    r'plusNanos',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusNanos = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusNanos(
    int j,
  ) {
    return _plusNanos(reference.pointer, _id_plusNanos as jni$_.JMethodIDPtr, j)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusSeconds = _class.instanceMethodId(
    r'plusSeconds',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusSeconds = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusSeconds(
    int j,
  ) {
    return _plusSeconds(
            reference.pointer, _id_plusSeconds as jni$_.JMethodIDPtr, j)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusWeeks = _class.instanceMethodId(
    r'plusWeeks',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusWeeks = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusWeeks(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusWeeks(
    int j,
  ) {
    return _plusWeeks(reference.pointer, _id_plusWeeks as jni$_.JMethodIDPtr, j)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusYears = _class.instanceMethodId(
    r'plusYears',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusYears = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusYears(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? plusYears(
    int j,
  ) {
    return _plusYears(reference.pointer, _id_plusYears as jni$_.JMethodIDPtr, j)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(reference.pointer, _id_query as jni$_.JMethodIDPtr,
            _$temporalQuery.pointer)
        .object<$R?>(R.nullableType);
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(
    jni$_.JObject? temporalField,
  ) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(reference.pointer, _id_range as jni$_.JMethodIDPtr,
            _$temporalField.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toLocalDate = _class.instanceMethodId(
    r'toLocalDate',
    r'()Ljava/time/LocalDate;',
  );

  static final _toLocalDate = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.LocalDate toLocalDate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? toLocalDate() {
    return _toLocalDate(
            reference.pointer, _id_toLocalDate as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toLocalDateTime = _class.instanceMethodId(
    r'toLocalDateTime',
    r'()Ljava/time/LocalDateTime;',
  );

  static final _toLocalDateTime = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.LocalDateTime toLocalDateTime()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? toLocalDateTime() {
    return _toLocalDateTime(
            reference.pointer, _id_toLocalDateTime as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toLocalTime = _class.instanceMethodId(
    r'toLocalTime',
    r'()Ljava/time/LocalTime;',
  );

  static final _toLocalTime = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.LocalTime toLocalTime()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? toLocalTime() {
    return _toLocalTime(
            reference.pointer, _id_toLocalTime as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toOffsetDateTime = _class.instanceMethodId(
    r'toOffsetDateTime',
    r'()Ljava/time/OffsetDateTime;',
  );

  static final _toOffsetDateTime = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.OffsetDateTime toOffsetDateTime()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? toOffsetDateTime() {
    return _toOffsetDateTime(
            reference.pointer, _id_toOffsetDateTime as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/ZonedDateTime;',
  );

  static final _truncatedTo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.ZonedDateTime truncatedTo(java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? truncatedTo(
    jni$_.JObject? temporalUnit,
  ) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(reference.pointer,
            _id_truncatedTo as jni$_.JMethodIDPtr, _$temporalUnit.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(
    jni$_.JObject? temporal,
    jni$_.JObject? temporalUnit,
  ) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(reference.pointer, _id_until as jni$_.JMethodIDPtr,
            _$temporal.pointer, _$temporalUnit.pointer)
        .long;
  }

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/ZonedDateTime;',
  );

  static final _with$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.ZonedDateTime with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? with$(
    jni$_.JObject? temporalAdjuster,
  ) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(reference.pointer, _id_with$ as jni$_.JMethodIDPtr,
            _$temporalAdjuster.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/ZonedDateTime;',
  );

  static final _with$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public java.time.ZonedDateTime with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? with$1(
    jni$_.JObject? temporalField,
    int j,
  ) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(reference.pointer, _id_with$1 as jni$_.JMethodIDPtr,
            _$temporalField.pointer, j)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withDayOfMonth = _class.instanceMethodId(
    r'withDayOfMonth',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withDayOfMonth = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withDayOfMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withDayOfMonth(
    int i,
  ) {
    return _withDayOfMonth(
            reference.pointer, _id_withDayOfMonth as jni$_.JMethodIDPtr, i)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withDayOfYear = _class.instanceMethodId(
    r'withDayOfYear',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withDayOfYear = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withDayOfYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withDayOfYear(
    int i,
  ) {
    return _withDayOfYear(
            reference.pointer, _id_withDayOfYear as jni$_.JMethodIDPtr, i)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withEarlierOffsetAtOverlap = _class.instanceMethodId(
    r'withEarlierOffsetAtOverlap',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _withEarlierOffsetAtOverlap =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.time.ZonedDateTime withEarlierOffsetAtOverlap()`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withEarlierOffsetAtOverlap() {
    return _withEarlierOffsetAtOverlap(reference.pointer,
            _id_withEarlierOffsetAtOverlap as jni$_.JMethodIDPtr)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withFixedOffsetZone = _class.instanceMethodId(
    r'withFixedOffsetZone',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _withFixedOffsetZone = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.ZonedDateTime withFixedOffsetZone()`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withFixedOffsetZone() {
    return _withFixedOffsetZone(
            reference.pointer, _id_withFixedOffsetZone as jni$_.JMethodIDPtr)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withHour = _class.instanceMethodId(
    r'withHour',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withHour = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withHour(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withHour(
    int i,
  ) {
    return _withHour(reference.pointer, _id_withHour as jni$_.JMethodIDPtr, i)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withLaterOffsetAtOverlap = _class.instanceMethodId(
    r'withLaterOffsetAtOverlap',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _withLaterOffsetAtOverlap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.ZonedDateTime withLaterOffsetAtOverlap()`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withLaterOffsetAtOverlap() {
    return _withLaterOffsetAtOverlap(reference.pointer,
            _id_withLaterOffsetAtOverlap as jni$_.JMethodIDPtr)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withMinute = _class.instanceMethodId(
    r'withMinute',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withMinute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withMinute(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withMinute(
    int i,
  ) {
    return _withMinute(
            reference.pointer, _id_withMinute as jni$_.JMethodIDPtr, i)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withMonth = _class.instanceMethodId(
    r'withMonth',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withMonth = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withMonth(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withMonth(
    int i,
  ) {
    return _withMonth(reference.pointer, _id_withMonth as jni$_.JMethodIDPtr, i)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withNano = _class.instanceMethodId(
    r'withNano',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withNano = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withNano(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withNano(
    int i,
  ) {
    return _withNano(reference.pointer, _id_withNano as jni$_.JMethodIDPtr, i)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withSecond = _class.instanceMethodId(
    r'withSecond',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withSecond = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withSecond(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withSecond(
    int i,
  ) {
    return _withSecond(
            reference.pointer, _id_withSecond as jni$_.JMethodIDPtr, i)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withYear = _class.instanceMethodId(
    r'withYear',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withYear = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withYear(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withYear(
    int i,
  ) {
    return _withYear(reference.pointer, _id_withYear as jni$_.JMethodIDPtr, i)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withZoneSameInstant = _class.instanceMethodId(
    r'withZoneSameInstant',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _withZoneSameInstant = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.ZonedDateTime withZoneSameInstant(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withZoneSameInstant(
    jni$_.JObject? zoneId,
  ) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _withZoneSameInstant(reference.pointer,
            _id_withZoneSameInstant as jni$_.JMethodIDPtr, _$zoneId.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withZoneSameLocal = _class.instanceMethodId(
    r'withZoneSameLocal',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _withZoneSameLocal = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.ZonedDateTime withZoneSameLocal(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  ZonedDateTime? withZoneSameLocal(
    jni$_.JObject? zoneId,
  ) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _withZoneSameLocal(reference.pointer,
            _id_withZoneSameLocal as jni$_.JMethodIDPtr, _$zoneId.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }
}

final class $ZonedDateTime$NullableType extends jni$_.JObjType<ZonedDateTime?> {
  @jni$_.internal
  const $ZonedDateTime$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZonedDateTime;';

  @jni$_.internal
  @core$_.override
  ZonedDateTime? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : ZonedDateTime.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZonedDateTime?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZonedDateTime$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZonedDateTime$NullableType) &&
        other is $ZonedDateTime$NullableType;
  }
}

final class $ZonedDateTime$Type extends jni$_.JObjType<ZonedDateTime> {
  @jni$_.internal
  const $ZonedDateTime$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZonedDateTime;';

  @jni$_.internal
  @core$_.override
  ZonedDateTime fromReference(jni$_.JReference reference) =>
      ZonedDateTime.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZonedDateTime?> get nullableType =>
      const $ZonedDateTime$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZonedDateTime$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZonedDateTime$Type) &&
        other is $ZonedDateTime$Type;
  }
}
