// AUTO GENERATED BY JNIGEN 0.14.2. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'ZoneOffset.dart' as zoneoffset$_;

import 'ZonedDateTime.dart' as zoneddatetime$_;

/// from: `java.time.Instant`
class Instant extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Instant> $type;

  @jni$_.internal
  Instant.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/Instant');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Instant$NullableType();
  static const type = $Instant$Type();
  static final _id_EPOCH = _class.staticFieldId(
    r'EPOCH',
    r'Ljava/time/Instant;',
  );

  /// from: `static public final java.time.Instant EPOCH`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? get EPOCH =>
      _id_EPOCH.get(_class, const $Instant$NullableType());

  static final _id_MAX = _class.staticFieldId(
    r'MAX',
    r'Ljava/time/Instant;',
  );

  /// from: `static public final java.time.Instant MAX`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? get MAX => _id_MAX.get(_class, const $Instant$NullableType());

  static final _id_MIN = _class.staticFieldId(
    r'MIN',
    r'Ljava/time/Instant;',
  );

  /// from: `static public final java.time.Instant MIN`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? get MIN => _id_MIN.get(_class, const $Instant$NullableType());

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(
    jni$_.JObject? temporal,
  ) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(reference.pointer, _id_adjustInto as jni$_.JMethodIDPtr,
            _$temporal.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_atOffset = _class.instanceMethodId(
    r'atOffset',
    r'(Ljava/time/ZoneOffset;)Ljava/time/OffsetDateTime;',
  );

  static final _atOffset = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.OffsetDateTime atOffset(java.time.ZoneOffset zoneOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? atOffset(
    zoneoffset$_.ZoneOffset? zoneOffset,
  ) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _atOffset(reference.pointer, _id_atOffset as jni$_.JMethodIDPtr,
            _$zoneOffset.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_atZone = _class.instanceMethodId(
    r'atZone',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _atZone = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.ZonedDateTime atZone(java.time.ZoneId zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  zoneddatetime$_.ZonedDateTime? atZone(
    jni$_.JObject? zoneId,
  ) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _atZone(reference.pointer, _id_atZone as jni$_.JMethodIDPtr,
            _$zoneId.pointer)
        .object<zoneddatetime$_.ZonedDateTime?>(
            const zoneddatetime$_.$ZonedDateTime$NullableType());
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/Instant;)I',
  );

  static final _compareTo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int compareTo(java.time.Instant instant)`
  int compareTo(
    Instant? instant,
  ) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _compareTo(reference.pointer, _id_compareTo as jni$_.JMethodIDPtr,
            _$instant.pointer)
        .integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/Instant;',
  );

  static final _from = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.Instant from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? from(
    jni$_.JObject? temporalAccessor,
  ) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(_class.reference.pointer, _id_from as jni$_.JMethodIDPtr,
            _$temporalAccessor.pointer)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(
    jni$_.JObject? temporalField,
  ) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(reference.pointer, _id_get as jni$_.JMethodIDPtr,
            _$temporalField.pointer)
        .integer;
  }

  static final _id_getEpochSecond = _class.instanceMethodId(
    r'getEpochSecond',
    r'()J',
  );

  static final _getEpochSecond = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getEpochSecond()`
  int getEpochSecond() {
    return _getEpochSecond(
            reference.pointer, _id_getEpochSecond as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(
    jni$_.JObject? temporalField,
  ) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(reference.pointer, _id_getLong as jni$_.JMethodIDPtr,
            _$temporalField.pointer)
        .long;
  }

  static final _id_getNano = _class.instanceMethodId(
    r'getNano',
    r'()I',
  );

  static final _getNano = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getNano()`
  int getNano() {
    return _getNano(reference.pointer, _id_getNano as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/Instant;)Z',
  );

  static final _isAfter = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean isAfter(java.time.Instant instant)`
  bool isAfter(
    Instant? instant,
  ) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _isAfter(reference.pointer, _id_isAfter as jni$_.JMethodIDPtr,
            _$instant.pointer)
        .boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/Instant;)Z',
  );

  static final _isBefore = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean isBefore(java.time.Instant instant)`
  bool isBefore(
    Instant? instant,
  ) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _isBefore(reference.pointer, _id_isBefore as jni$_.JMethodIDPtr,
            _$instant.pointer)
        .boolean;
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(
    jni$_.JObject? temporalField,
  ) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(reference.pointer,
            _id_isSupported as jni$_.JMethodIDPtr, _$temporalField.pointer)
        .boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit temporalUnit)`
  bool isSupported$1(
    jni$_.JObject? temporalUnit,
  ) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(reference.pointer,
            _id_isSupported$1 as jni$_.JMethodIDPtr, _$temporalUnit.pointer)
        .boolean;
  }

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Instant;',
  );

  static final _minus = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.Instant minus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? minus(
    jni$_.JObject? temporalAmount,
  ) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _minus(reference.pointer, _id_minus as jni$_.JMethodIDPtr,
            _$temporalAmount.pointer)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Instant;',
  );

  static final _minus$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.Instant minus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? minus$1(
    int j,
    jni$_.JObject? temporalUnit,
  ) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _minus$1(reference.pointer, _id_minus$1 as jni$_.JMethodIDPtr, j,
            _$temporalUnit.pointer)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minusMillis = _class.instanceMethodId(
    r'minusMillis',
    r'(J)Ljava/time/Instant;',
  );

  static final _minusMillis = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.Instant minusMillis(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? minusMillis(
    int j,
  ) {
    return _minusMillis(
            reference.pointer, _id_minusMillis as jni$_.JMethodIDPtr, j)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minusNanos = _class.instanceMethodId(
    r'minusNanos',
    r'(J)Ljava/time/Instant;',
  );

  static final _minusNanos = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.Instant minusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? minusNanos(
    int j,
  ) {
    return _minusNanos(
            reference.pointer, _id_minusNanos as jni$_.JMethodIDPtr, j)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minusSeconds = _class.instanceMethodId(
    r'minusSeconds',
    r'(J)Ljava/time/Instant;',
  );

  static final _minusSeconds = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.Instant minusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? minusSeconds(
    int j,
  ) {
    return _minusSeconds(
            reference.pointer, _id_minusSeconds as jni$_.JMethodIDPtr, j)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/Instant;',
  );

  static final _now = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.time.Instant now()`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? now() {
    return _now(_class.reference.pointer, _id_now as jni$_.JMethodIDPtr)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/Instant;',
  );

  static final _now$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.Instant now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? now$1(
    jni$_.JObject? clock,
  ) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$1(_class.reference.pointer, _id_now$1 as jni$_.JMethodIDPtr,
            _$clock.pointer)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_ofEpochMilli = _class.staticMethodId(
    r'ofEpochMilli',
    r'(J)Ljava/time/Instant;',
  );

  static final _ofEpochMilli = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public java.time.Instant ofEpochMilli(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? ofEpochMilli(
    int j,
  ) {
    return _ofEpochMilli(
            _class.reference.pointer, _id_ofEpochMilli as jni$_.JMethodIDPtr, j)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_ofEpochSecond = _class.staticMethodId(
    r'ofEpochSecond',
    r'(J)Ljava/time/Instant;',
  );

  static final _ofEpochSecond = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public java.time.Instant ofEpochSecond(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? ofEpochSecond(
    int j,
  ) {
    return _ofEpochSecond(_class.reference.pointer,
            _id_ofEpochSecond as jni$_.JMethodIDPtr, j)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_ofEpochSecond$1 = _class.staticMethodId(
    r'ofEpochSecond',
    r'(JJ)Ljava/time/Instant;',
  );

  static final _ofEpochSecond$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int64, jni$_.Int64)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `static public java.time.Instant ofEpochSecond(long j, long j1)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? ofEpochSecond$1(
    int j,
    int j1,
  ) {
    return _ofEpochSecond$1(_class.reference.pointer,
            _id_ofEpochSecond$1 as jni$_.JMethodIDPtr, j, j1)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/Instant;',
  );

  static final _parse = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.Instant parse(java.lang.CharSequence charSequence)`
  /// The returned object must be released after use, by calling the [release] method.
  static Instant? parse(
    jni$_.JObject? charSequence,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _parse(_class.reference.pointer, _id_parse as jni$_.JMethodIDPtr,
            _$charSequence.pointer)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Instant;',
  );

  static final _plus = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.Instant plus(java.time.temporal.TemporalAmount temporalAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? plus(
    jni$_.JObject? temporalAmount,
  ) {
    final _$temporalAmount = temporalAmount?.reference ?? jni$_.jNullReference;
    return _plus(reference.pointer, _id_plus as jni$_.JMethodIDPtr,
            _$temporalAmount.pointer)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Instant;',
  );

  static final _plus$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.Instant plus(long j, java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? plus$1(
    int j,
    jni$_.JObject? temporalUnit,
  ) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _plus$1(reference.pointer, _id_plus$1 as jni$_.JMethodIDPtr, j,
            _$temporalUnit.pointer)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plusMillis = _class.instanceMethodId(
    r'plusMillis',
    r'(J)Ljava/time/Instant;',
  );

  static final _plusMillis = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.Instant plusMillis(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? plusMillis(
    int j,
  ) {
    return _plusMillis(
            reference.pointer, _id_plusMillis as jni$_.JMethodIDPtr, j)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plusNanos = _class.instanceMethodId(
    r'plusNanos',
    r'(J)Ljava/time/Instant;',
  );

  static final _plusNanos = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.Instant plusNanos(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? plusNanos(
    int j,
  ) {
    return _plusNanos(reference.pointer, _id_plusNanos as jni$_.JMethodIDPtr, j)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plusSeconds = _class.instanceMethodId(
    r'plusSeconds',
    r'(J)Ljava/time/Instant;',
  );

  static final _plusSeconds = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.Instant plusSeconds(long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? plusSeconds(
    int j,
  ) {
    return _plusSeconds(
            reference.pointer, _id_plusSeconds as jni$_.JMethodIDPtr, j)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(reference.pointer, _id_query as jni$_.JMethodIDPtr,
            _$temporalQuery.pointer)
        .object<$R?>(R.nullableType);
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(
    jni$_.JObject? temporalField,
  ) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(reference.pointer, _id_range as jni$_.JMethodIDPtr,
            _$temporalField.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toEpochMilli = _class.instanceMethodId(
    r'toEpochMilli',
    r'()J',
  );

  static final _toEpochMilli = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long toEpochMilli()`
  int toEpochMilli() {
    return _toEpochMilli(
            reference.pointer, _id_toEpochMilli as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/Instant;',
  );

  static final _truncatedTo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.Instant truncatedTo(java.time.temporal.TemporalUnit temporalUnit)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? truncatedTo(
    jni$_.JObject? temporalUnit,
  ) {
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(reference.pointer,
            _id_truncatedTo as jni$_.JMethodIDPtr, _$temporalUnit.pointer)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public long until(java.time.temporal.Temporal temporal, java.time.temporal.TemporalUnit temporalUnit)`
  int until(
    jni$_.JObject? temporal,
    jni$_.JObject? temporalUnit,
  ) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$temporalUnit = temporalUnit?.reference ?? jni$_.jNullReference;
    return _until(reference.pointer, _id_until as jni$_.JMethodIDPtr,
            _$temporal.pointer, _$temporalUnit.pointer)
        .long;
  }

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/Instant;',
  );

  static final _with$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.Instant with(java.time.temporal.TemporalAdjuster temporalAdjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? with$(
    jni$_.JObject? temporalAdjuster,
  ) {
    final _$temporalAdjuster =
        temporalAdjuster?.reference ?? jni$_.jNullReference;
    return _with$(reference.pointer, _id_with$ as jni$_.JMethodIDPtr,
            _$temporalAdjuster.pointer)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/Instant;',
  );

  static final _with$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public java.time.Instant with(java.time.temporal.TemporalField temporalField, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  Instant? with$1(
    jni$_.JObject? temporalField,
    int j,
  ) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _with$1(reference.pointer, _id_with$1 as jni$_.JMethodIDPtr,
            _$temporalField.pointer, j)
        .object<Instant?>(const $Instant$NullableType());
  }

  bool operator <(Instant? instant) {
    return compareTo(instant) < 0;
  }

  bool operator <=(Instant? instant) {
    return compareTo(instant) <= 0;
  }

  bool operator >(Instant? instant) {
    return compareTo(instant) > 0;
  }

  bool operator >=(Instant? instant) {
    return compareTo(instant) >= 0;
  }
}

final class $Instant$NullableType extends jni$_.JObjType<Instant?> {
  @jni$_.internal
  const $Instant$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Instant;';

  @jni$_.internal
  @core$_.override
  Instant? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Instant.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Instant?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Instant$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Instant$NullableType) &&
        other is $Instant$NullableType;
  }
}

final class $Instant$Type extends jni$_.JObjType<Instant> {
  @jni$_.internal
  const $Instant$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Instant;';

  @jni$_.internal
  @core$_.override
  Instant fromReference(jni$_.JReference reference) => Instant.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Instant?> get nullableType => const $Instant$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Instant$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Instant$Type) && other is $Instant$Type;
  }
}
