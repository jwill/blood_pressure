// AUTO GENERATED BY JNIGEN 0.14.2. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `java.time.ZoneOffset`
class ZoneOffset extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ZoneOffset> $type;

  @jni$_.internal
  ZoneOffset.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/ZoneOffset');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ZoneOffset$NullableType();
  static const type = $ZoneOffset$Type();
  static final _id_MAX = _class.staticFieldId(
    r'MAX',
    r'Ljava/time/ZoneOffset;',
  );

  /// from: `static public final java.time.ZoneOffset MAX`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? get MAX =>
      _id_MAX.get(_class, const $ZoneOffset$NullableType());

  static final _id_MIN = _class.staticFieldId(
    r'MIN',
    r'Ljava/time/ZoneOffset;',
  );

  /// from: `static public final java.time.ZoneOffset MIN`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? get MIN =>
      _id_MIN.get(_class, const $ZoneOffset$NullableType());

  static final _id_UTC = _class.staticFieldId(
    r'UTC',
    r'Ljava/time/ZoneOffset;',
  );

  /// from: `static public final java.time.ZoneOffset UTC`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? get UTC =>
      _id_UTC.get(_class, const $ZoneOffset$NullableType());

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/String;)Ljava/time/ZoneOffset;',
  );

  static final _of = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZoneOffset of(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? of(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _of(_class.reference.pointer, _id_of as jni$_.JMethodIDPtr,
            _$string.pointer)
        .object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_ofHours = _class.staticMethodId(
    r'ofHours',
    r'(I)Ljava/time/ZoneOffset;',
  );

  static final _ofHours = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public java.time.ZoneOffset ofHours(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? ofHours(
    int i,
  ) {
    return _ofHours(
            _class.reference.pointer, _id_ofHours as jni$_.JMethodIDPtr, i)
        .object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_ofHoursMinutes = _class.staticMethodId(
    r'ofHoursMinutes',
    r'(II)Ljava/time/ZoneOffset;',
  );

  static final _ofHoursMinutes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `static public java.time.ZoneOffset ofHoursMinutes(int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? ofHoursMinutes(
    int i,
    int i1,
  ) {
    return _ofHoursMinutes(_class.reference.pointer,
            _id_ofHoursMinutes as jni$_.JMethodIDPtr, i, i1)
        .object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_ofHoursMinutesSeconds = _class.staticMethodId(
    r'ofHoursMinutesSeconds',
    r'(III)Ljava/time/ZoneOffset;',
  );

  static final _ofHoursMinutesSeconds = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int, int)>();

  /// from: `static public java.time.ZoneOffset ofHoursMinutesSeconds(int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? ofHoursMinutesSeconds(
    int i,
    int i1,
    int i2,
  ) {
    return _ofHoursMinutesSeconds(_class.reference.pointer,
            _id_ofHoursMinutesSeconds as jni$_.JMethodIDPtr, i, i1, i2)
        .object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/ZoneOffset;',
  );

  static final _from = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZoneOffset from(java.time.temporal.TemporalAccessor temporalAccessor)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? from(
    jni$_.JObject? temporalAccessor,
  ) {
    final _$temporalAccessor =
        temporalAccessor?.reference ?? jni$_.jNullReference;
    return _from(_class.reference.pointer, _id_from as jni$_.JMethodIDPtr,
            _$temporalAccessor.pointer)
        .object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_ofTotalSeconds = _class.staticMethodId(
    r'ofTotalSeconds',
    r'(I)Ljava/time/ZoneOffset;',
  );

  static final _ofTotalSeconds = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public java.time.ZoneOffset ofTotalSeconds(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static ZoneOffset? ofTotalSeconds(
    int i,
  ) {
    return _ofTotalSeconds(_class.reference.pointer,
            _id_ofTotalSeconds as jni$_.JMethodIDPtr, i)
        .object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_getTotalSeconds = _class.instanceMethodId(
    r'getTotalSeconds',
    r'()I',
  );

  static final _getTotalSeconds = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getTotalSeconds()`
  int getTotalSeconds() {
    return _getTotalSeconds(
            reference.pointer, _id_getTotalSeconds as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getId() {
    return _getId(reference.pointer, _id_getId as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getRules = _class.instanceMethodId(
    r'getRules',
    r'()Ljava/time/zone/ZoneRules;',
  );

  static final _getRules = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.zone.ZoneRules getRules()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getRules() {
    return _getRules(reference.pointer, _id_getRules as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField temporalField)`
  bool isSupported(
    jni$_.JObject? temporalField,
  ) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _isSupported(reference.pointer,
            _id_isSupported as jni$_.JMethodIDPtr, _$temporalField.pointer)
        .boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField temporalField)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? range(
    jni$_.JObject? temporalField,
  ) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _range(reference.pointer, _id_range as jni$_.JMethodIDPtr,
            _$temporalField.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int get(java.time.temporal.TemporalField temporalField)`
  int get(
    jni$_.JObject? temporalField,
  ) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _get(reference.pointer, _id_get as jni$_.JMethodIDPtr,
            _$temporalField.pointer)
        .integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public long getLong(java.time.temporal.TemporalField temporalField)`
  int getLong(
    jni$_.JObject? temporalField,
  ) {
    final _$temporalField = temporalField?.reference ?? jni$_.jNullReference;
    return _getLong(reference.pointer, _id_getLong as jni$_.JMethodIDPtr,
            _$temporalField.pointer)
        .long;
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public R query(java.time.temporal.TemporalQuery temporalQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? temporalQuery, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$temporalQuery = temporalQuery?.reference ?? jni$_.jNullReference;
    return _query(reference.pointer, _id_query as jni$_.JMethodIDPtr,
            _$temporalQuery.pointer)
        .object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? adjustInto(
    jni$_.JObject? temporal,
  ) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(reference.pointer, _id_adjustInto as jni$_.JMethodIDPtr,
            _$temporal.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/ZoneOffset;)I',
  );

  static final _compareTo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int compareTo(java.time.ZoneOffset zoneOffset)`
  int compareTo(
    ZoneOffset? zoneOffset,
  ) {
    final _$zoneOffset = zoneOffset?.reference ?? jni$_.jNullReference;
    return _compareTo(reference.pointer, _id_compareTo as jni$_.JMethodIDPtr,
            _$zoneOffset.pointer)
        .integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  bool operator <(ZoneOffset? zoneOffset) {
    return compareTo(zoneOffset) < 0;
  }

  bool operator <=(ZoneOffset? zoneOffset) {
    return compareTo(zoneOffset) <= 0;
  }

  bool operator >(ZoneOffset? zoneOffset) {
    return compareTo(zoneOffset) > 0;
  }

  bool operator >=(ZoneOffset? zoneOffset) {
    return compareTo(zoneOffset) >= 0;
  }
}

final class $ZoneOffset$NullableType extends jni$_.JObjType<ZoneOffset?> {
  @jni$_.internal
  const $ZoneOffset$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZoneOffset;';

  @jni$_.internal
  @core$_.override
  ZoneOffset? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : ZoneOffset.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZoneOffset?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZoneOffset$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoneOffset$NullableType) &&
        other is $ZoneOffset$NullableType;
  }
}

final class $ZoneOffset$Type extends jni$_.JObjType<ZoneOffset> {
  @jni$_.internal
  const $ZoneOffset$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZoneOffset;';

  @jni$_.internal
  @core$_.override
  ZoneOffset fromReference(jni$_.JReference reference) =>
      ZoneOffset.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZoneOffset?> get nullableType =>
      const $ZoneOffset$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZoneOffset$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoneOffset$Type) && other is $ZoneOffset$Type;
  }
}
